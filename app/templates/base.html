<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>TechScan</title>
  <link rel="icon" type="image/svg+xml" href="/static/assets/images/favicon.svg" />
  <link rel="alternate icon" type="image/png" href="/static/assets/images/logo.png" />
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@picocss/pico@2/css/pico.min.css">
  <link rel="stylesheet" href="/static/techscan.css">
  <style>body { padding-top:4.2rem; }</style>
  <script>
    // Ensure apiFetch is available as early as possible
    (function(){
      if(!window.apiFetch){
        window.apiFetch = async function(path, opts={}) {
          const r = await fetch(path, opts);
          if(!r.ok) throw new Error('HTTP '+r.status);
          return r.json();
        };
      }
    })();
  </script>
</head>
<body>
  <div class="ts-caustic-layer" aria-hidden="true"></div>
  <nav class="ts-nav glass-surface glass-surface--intense">
    <div class="ts-nav-inner">
    <a href="/" class="ts-brand" aria-label="Home">
  <img src="/static/assets/images/logo.svg" alt="TechScan" class="ts-logo" onerror="this.style.display='none'" />
        <span class="ts-brand-text">TechScan</span>
      </a>
      <ul class="ts-nav-links">
        <li><a href="/dashboard">Lookup</a></li>
        <li><a href="/websites">Websites</a></li>
        <li><a href="/technology">Technology Search</a></li>
        <li><a href="/history">History</a></li>
        <li><a href="/stats">Stats</a></li>
      </ul>
      <div class="ts-nav-tools">
        <button id="theme-toggle" class="theme-toggle" aria-label="Toggle theme">ðŸŒ™</button>
      </div>
    </div>
  </nav>
  <main class="container">
    {% block content %}{% endblock %}
  </main>
  {# Include tech modal partial used across pages #}
  {% include '_tech_modal.html' %}
  <script src="/static/js/tech_modal.js?v=2"></script>
  <script>
    // Theme toggle only
    (function(){
      const THEME_KEY='ts-theme';
      const themeBtn=document.getElementById('theme-toggle');
      requestAnimationFrame(()=>document.body.classList.add('theme-transition'));
      const applyTheme=(mode)=>{
        document.body.classList.toggle('light', mode==='light');
        if(themeBtn) themeBtn.textContent = mode==='light' ? 'ðŸŒš' : 'ðŸŒ™';
      };
      applyTheme(localStorage.getItem(THEME_KEY)||'dark');
      themeBtn&&themeBtn.addEventListener('click',()=>{
        const cur=document.body.classList.contains('light')?'light':'dark';
        const next= cur==='light'?'dark':'light';
        localStorage.setItem(THEME_KEY,next);
        applyTheme(next);
      });
    })();
    // Auto active state for nav links with smooth transition
    (function(){
      const path = location.pathname.replace(/\/$/,'');
      document.querySelectorAll('.ts-nav-links a').forEach(a=>{
        const href = a.getAttribute('href');
        if(!href) return;
        const norm = href.replace(/\/$/,'');
        if(norm && (path===norm || (path.startsWith(norm) && norm!=='/' && path.split('/').length===norm.split('/').length))){
          a.classList.add('active');
        }
      });
    })();
    
    // Page load animation - add fade-in class to main content
    (function(){
      const main = document.querySelector('main.container');
      if(main){
        // Ensure animation plays on page load
        main.style.opacity = '0';
        requestAnimationFrame(() => {
          requestAnimationFrame(() => {
            main.style.opacity = '';
            main.classList.add('page-loaded');
          });
        });
      }
    })();
    
    // Progressive reveal for grid items (if present)
    (function(){
      const grids = document.querySelectorAll('.tech-grid, .domain-grid, .category-grid, .dashboard-wrapper > *');
      if(!grids.length) return;
      
      if('IntersectionObserver' in window){
        const observer = new IntersectionObserver((entries) => {
          entries.forEach((entry, index) => {
            if(entry.isIntersecting){
              setTimeout(() => {
                entry.target.style.opacity = '1';
                entry.target.style.transform = 'translateY(0)';
              }, index * 50); // 50ms stagger
              observer.unobserve(entry.target);
            }
          });
        }, {threshold: 0.1});
        
        grids.forEach((grid) => {
          const items = grid.children;
          Array.from(items).forEach((item, i) => {
            item.style.opacity = '0';
            item.style.transform = 'translateY(20px)';
            item.style.transition = 'opacity 0.4s ease-out, transform 0.4s cubic-bezier(0.22, 0.72, 0.18, 0.99)';
            observer.observe(item);
          });
        });
      }
    })();
    // Bubbles for caustic layer (randomized circular orbits) â€” ensure visible, subtle motion
    (function(){
      const layer = document.querySelector('.ts-caustic-layer');
      if(!layer) return;
      if(layer.dataset.bubblesInit==='1') return; // prevent duplicates
      layer.dataset.bubblesInit='1';
  const rand=(min,max)=> Math.random()*(max-min)+min;
      const pick=(arr)=> arr[Math.floor(Math.random()*arr.length)];
    // Fewer, larger bubbles with continuous orbits
  const count = 6;
  const sizes = [260, 320, 380, 440, 520];
  const orbitsVh = [18, 26, 34, 42, 50];
      for(let i=0;i<count;i++){
        // orbit wrapper controls rotation; inner bubble handles pulse/hue and radial offset
        const wrapper = document.createElement('div');
        wrapper.className = 'bubble-orbit';
        const b = document.createElement('div');
        b.className = 'bubble';
        const size = pick(sizes);
        const orbit = pick(orbitsVh);
        // Moderate, continuous motion
        const speed = rand(22, 36); // slower, long orbits (seconds)
        const pulse = rand(8, 14);
        const hue = rand(22, 36);
        const angle = rand(0,360);
        const opacity = rand(0.42, 0.62); // more subtle
        // random delays to desync animations for more organic motion
        const delayOrbit = rand(-6, 6);
        const delayPulse = rand(-2, 2);
        const delayHue = rand(-4, 4);
        // style vars for wrapper and bubble
        wrapper.style.setProperty('--b-speed', speed+'s');
        wrapper.style.setProperty('--b-angle', angle+'deg');
        wrapper.style.setProperty('--b-delay', delayOrbit+'s');
        // Randomize orbit center on wrapper
        const leftPct = rand(18, 82);
        const topPct = rand(18, 82);
        wrapper.style.setProperty('--center-x', leftPct+'%');
        wrapper.style.setProperty('--center-y', topPct+'%');
        // Bubble visuals and radial offset
        b.style.setProperty('--b-size', size+'px');
        b.style.setProperty('--b-orbit', orbit+'vh');
        b.style.setProperty('--b-pulse', pulse+'s');
        b.style.setProperty('--b-hue', hue+'s');
        b.style.setProperty('--b-opacity', opacity);
        b.style.setProperty('--b-pulse-delay', delayPulse+'s');
        b.style.setProperty('--b-hue-delay', delayHue+'s');
        // Assemble
        wrapper.appendChild(b);
        layer.appendChild(wrapper);
      }
    })();
  </script>
  {% block scripts %}{% endblock %}
</body>
</html>
